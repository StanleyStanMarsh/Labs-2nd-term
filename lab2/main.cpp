// Темы:
// Простое наследование. Виртуальные функции. Абстрактные классы.
// [Битовые поля.]
#include <iostream>
#include <tchar.h>
#include "myString.h"
#include "Shape.h"
#include "Circle.h"
#include "Rect.h"
#include "MyByte.h"

int main(int argc, _TCHAR* argv[])
{
    setbuf(stdout, 0);
	//Задание 1.Массив объектов класса.
	{
        std::cout << "\n______Task #1______\n";
	//Объявите и проинициализируйте массив ar из объектов
	// типа MyString.
		MyString str1[3] = {"first", "second", "third"};

	//Проверка - печать строк-членов класса
        std::cout << str1[0].GetString() << ' ' << str1[1].GetString() << ' ' << str1[2].GetString() << '\n';

	//Замените размер "3" на "5", не изменяя список инициализаторов.
        MyString str2[5] = {"first", "second", "third"};
	}


	//Задание 2.Массив указателей на объекты класса.
	{
        std::cout << "\n______Task #2______\n";
        MyString str1[3] = {"first", "second", "third"};
	//Объявите и проинициализируйте массив arPtr из трех
	//указателей на объекты типа MyString.
        MyString * arPtr[3];
        for (int i = 0; i < 3; i++) {
            arPtr[i] = &str1[i];
        }

	//Печать строк-членов класса
        std::cout << arPtr[0]->GetString() << ' ' << arPtr[1]->GetString() << ' ' << arPtr[2]->GetString() << '\n';

	}

	//Задание 3.Простое наследование.Аргументы конструктора,
	// передаваемые в базовый класс.

	//Создайте иерархию классов:
	//базовый класс Shape (который описывает любую фигуру)
	//и два производных класса Rect и Circle.
	//Подумайте: какие данные и методы нужно ввести в базовый
	//и производные классы (например, любую фигуру можно сделать
	//цветной => в базовом классе можно ввести переменную, которая
	//будет определять цвет фигуры.
	//Подсказка: для хранения цвета объявите перечисление (RED,GREEN,BLUE...);



	//В конструкторах производных классов предусмотрите передачу
	//параметра-цвета конструктору базового класса.
	//При создании и уничтожении объекта производного типа определите
	//последовательность вызовов конструкторов и деструкторов базового
	//и производного классов




//////////////////////////////////////////////////////////////////////
	//Задание 4.Виртуальные функции.
	//4а) Модифицируйте классы Shape,Rect и Circle:
	//добавьте в каждый класс public метод void WhereAmI().
	//Реализация каждой функции должна выводить сообщение
	//следующего вида "Now I am in class Shape(Rect или Circle)".
	//Выполните приведенный фрагмент, объясните результат.

	//4б) Сделайте метод WhereAmI() виртуальным.
	//Снова выполните приведенный фрагмент, объясните разницу.

	{
        std::cout << "\n______Task #4______\n";
		Shape s;
		Rect r;
		Circle c;


		//Метод какого класса вызывается в следующих строчках???
		s.WhereAmI();	//	Shape
		r.WhereAmI();	//	Rect
		c.WhereAmI();	//	Circle
        // оба раза один результат

		Shape* pShape = &s;
		Shape* pRect = &r;
		Shape* pCircle = &c;
    	pShape->WhereAmI();	//	Shape Shape
		pRect->WhereAmI();	//	Shape Rect
		pCircle->WhereAmI(); //	Shape Circle


		//Заполните ... согласно комментариям
		Shape& rShape = s; //псевдоним s
		Shape& rRect = r; //псевдоним r
		Shape& rCircle = c; //псевдоним c
    	rShape.WhereAmI();	//вызов посредством rShape	Shape Shape
		rRect.WhereAmI();	//вызов посредством	rRect	Shape Rect
		rCircle.WhereAmI(); //вызов посредством rCircle	Shape Circle

	}

//////////////////////////////////////////////////////////////////////
	//Задание 5.Виртуальные деструкторы.
	//Модифицируйте классы:
	//a) введите соответствующие
	// деструкторы (без ключевого слова virtual).
	//Реализация каждого деструктора
	//должна выводить сообщение следующего вида
	// "Now I am in Shape's destructor!" или
	// "Now I am in Rect's destructor!"
	//Выполните фрагмент. Объясните результат.

	// b) Добавьте в объявление деструкторов ключевое слово virtual
	//Выполните фрагмент.Объясните разницу.


	//Подумайте: какие конструкторы вызываются в следующей строке?
		//Если в разработанных классов каких-то конструкторов
		//не хватает - реализуйте
		//Если Вы считаете, что в приведенном фрагменте чего-то
		//не хватает - добавьте
    std::cout << "\n______Task #5______\n";
		Rect r(1, 2, 3, 4, colors::RED);
		Shape* ar[]={new Shape(r), new Rect(r), new Circle(r), new Circle() };
		//Вызовите для каждого элемента массива метод WhereAmI()
    for (int i = 0; i < 4; i++) {
        ar[i]->WhereAmI();
    }
    // Shape, Rect, Circle, Circle
    std::cout << '\n';
    for (int i = 0; i < 4; i++) {
        delete ar[i];
    }
    // без virtual Shape, Shape, Shape, Shape (т.к. указатели типа Shape)
    // с virtual Shape; Rect, Shape; Circle, Shape; Circle, Shape

	//Задание 6*. В чем заключается отличие 1) и 2)
	{
        std::cout << "\n______Task #6______\n";
		Shape* pShapes = new Rect[10];//1)
		Rect* pRects = new Rect[10];//2)
        std::cout << "Shape = " << sizeof(Shape) << "\nRect = " << sizeof(Rect) << '\n';
        //Shape = 16
        //Rect = 32

        //1)выделяется неверное количество памяти, так как Shape < Rect => при проходе по массиву
        //	будет неверно вычисляться адрес (прибавляется не 32 байта, а 16)
		//Попробуйте вызвать метод WhereAmI() для каждого элемента обоих массивов -
		//в чем заключается проблема???
        for (int i = 0; i < 10; i++) {
            dynamic_cast<Rect*>(pShapes)[i].WhereAmI();
        }

        for (int i = 0; i < 10; i++) {
            pRects[i].WhereAmI();
        }

		//Освободите динамически захваченную память
        delete[] pShapes;
        std::cout << '\n';
        delete[] pRects;
	}


//////////////////////////////////////////////////////////////////////
	//Задание 7.Виртуальные функции и оператор разрешения области видимости.

	{
        std::cout << "\n______Task #7______\n";
		Rect r;
		Shape* p = &r;
		p->WhereAmI(); // Rect
        p->Shape::WhereAmI(); // Shape

		//4a Оператор разрешения области видимости.
		//Посредством объекта r и указателя p вызовите виртуальную функцию
		//WhereAmI()класса Shape


	}

//////////////////////////////////////////////////////////////////////
	//Задание 8.Чисто виртуальные функции.
	//Введите в базовый класс метод void Inflate(int); Подумайте:
	//можно ли реализовать такой метод для базового класса? => как его нужно объявить.
	//Реализуйте этот метод для производных классов.
	{
        std::cout << "\n______Task #8______\n";
		Rect r;
		Shape* p = &r;
		p->Inflate(5);
		Circle c;
		p = &c;
		p->Inflate(5);
	}


//////////////////////////////////////////////////////////////////////
	//Задание 9. Создайте глобальную функцию, которая будет принимать любое
	//количество указателей на строки, а возвращать объект MyString,
	//в котором строка будет конкатенацией параметров
    std::cout << "\n______Task #9______\n";
    MyString str1 = "Hello";
    MyString str2 = "World";
    MyString str3 = "!!!";
    std::cout << (str_concat(3, str1, str2, str3)).GetString() << '\n';

////////////////////////////////////////////////////////////////////////
    std::cout << "\n______Task #10______\n";
	//Задание 10. Объединения (union) C++. Битовые поля.
	//1.
	//Создайте следующие классы для различных представлений значений байта:
	//Bin - для двоичного представления
	//Hex - для шестнадцатерчного представления
	//Oct - для восьмеричного представления.
	//Подсказка 1: - для удобства используйте битовые поля.
	//Подсказка 2: - конструкторов в таких вспомогательных классах быть не должно,
	//так как все они будут членами объединения (union).
	//2.
	//В каждом классе введите метод Show, который должен выводить значение в
	//соответствующем виде
	//3.
	//Посредством объединения MyByte предоставьте пользователю возможность манипулировать
	//одним и тем же значением по-разному:
	//а) выводить: десятичное, шестнадцатеричное, восьмеричное, двоичное значение байта
	//          а также символ, соответствующий хранимому значению (если есть соответствие);
	//б) выводить отдельные (указанные посредством параметра) шестнадцатеричные,
	//			восьмеричные, двоичные цифры;
	//в) изменять отдельные двоичные, восьмеричные или шестнадцатеричные цифры;

	MyByte byte(0x1f);
	byte.ShowHex();
	byte.ShowBin();
	byte.ShowDec();
    byte.ShowChar();
    std::cout << '\n';

    byte.ShowBinDigit(4);
    byte.ShowHexDigit(2);
    byte.ShowOctDigit(2);
    std::cout << '\n';

    byte.ShowHex();
    byte.ChangeHexDigit(1, 4);
    byte.ShowHex();
    std::cout << '\n';

	return 0;
}//endmain

